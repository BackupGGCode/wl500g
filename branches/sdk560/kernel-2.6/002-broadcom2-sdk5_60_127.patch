diff -urBp a/arch/mips/brcm-boards/bcm947xx/Makefile b/arch/mips/brcm-boards/bcm947xx/Makefile
--- a/arch/mips/brcm-boards/bcm947xx/Makefile	2009-11-26 02:33:36.000000000 +0300
+++ b/arch/mips/brcm-boards/bcm947xx/Makefile	2010-11-24 20:51:10.000000000 +0300
@@ -28,6 +23,10 @@ ifeq ($(CONFIG_PCI),y)
 BCM947XX_OBJS += $(addprefix $(SHARED)/, hndpci.o) pcibios.o
 endif
 
+ifeq ($(CONFIG_WAPI),y)
+EXTRA_CFLAGS += -DBCMWAPI_WAI
+endif
+
 ifeq ($(CONFIG_GENERIC_GPIO),y)
 BCM947XX_OBJS += gen_gpio.o
 endif
diff -urBp a/arch/mips/brcm-boards/bcm947xx/gpio.c b/arch/mips/brcm-boards/bcm947xx/gpio.c
--- a/arch/mips/brcm-boards/bcm947xx/gpio.c
+++ b/arch/mips/brcm-boards/bcm947xx/gpio.c
@@ -63,13 +79,13 @@ gpio_read(struct file *file, char *buf,
 		val = si_gpioin(gpio_sih);
 		break;
 	case 1:
-		val = si_gpioout(gpio_sih, 0, 0);
+		val = si_gpioout(gpio_sih, 0, 0, GPIO_DRV_PRIORITY);
 		break;
 	case 2:
-		val = si_gpioouten(gpio_sih, 0, 0);
+		val = si_gpioouten(gpio_sih, 0, 0, GPIO_DRV_PRIORITY);
 		break;
 	case 3:
-		val = si_gpiocontrol(gpio_sih, 0, 0);
+		val = si_gpiocontrol(gpio_sih, 0, 0, GPIO_DRV_PRIORITY);
 		break;
 	default:
 		return -ENODEV;
@@ -93,13 +109,13 @@ gpio_write(struct file *file, const char
 	case 0:
 		return -EACCES;
 	case 1:
-		si_gpioout(gpio_sih, ~0, val);
+		si_gpioout(gpio_sih, ~0, val, GPIO_DRV_PRIORITY);
 		break;
 	case 2:
-		si_gpioouten(gpio_sih, ~0, val);
+		si_gpioouten(gpio_sih, ~0, val, GPIO_DRV_PRIORITY);
 		break;
 	case 3:
-		si_gpiocontrol(gpio_sih, ~0, val);
+		si_gpiocontrol(gpio_sih, ~0, val, GPIO_DRV_PRIORITY);
 		break;
 	default:
 		return -ENODEV;
diff -urBp a/arch/mips/brcm-boards/bcm947xx/pcibios.c b/arch/mips/brcm-boards/bcm947xx/pcibios.c
--- a/arch/mips/brcm-boards/bcm947xx/pcibios.c	2009-11-26 02:33:36.000000000 +0300
+++ b/arch/mips/brcm-boards/bcm947xx/pcibios.c	2010-11-22 12:00:16.000000000 +0300
@@ -256,8 +257,53 @@ pcibios_enable_device(struct pci_dev *de
 			si_core_reset(sih, 0, 0);
 			// USB hungup issue from broadcom 2009.6.24
 			mdelay(10);
-			writel(0x7ff, regs + 0x200);
-			udelay(1);
+			if (si_corerev(sih) >= 5) {
+				uint32 tmp;
+				/* Enable Misc PLL */
+				tmp = readl(regs + 0x1e0);
+				tmp |= 0x100;
+				writel(tmp, regs + 0x1e0);
+				SPINWAIT((((tmp = readl(regs + 0x1e0)) & (1 << 24))
+					== 0), 1000);
+				/* Take out of resets */
+				writel(0x4ff, regs + 0x200);
+				udelay(25);
+				writel(0x6ff, regs + 0x200);
+				udelay(25);
+
+				/* Make sure digital and AFE are locked in USB PHY */
+				writel(0x6b, regs + 0x524);
+				udelay(50);
+				tmp = readl(regs + 0x524);
+				udelay(50);
+				writel(0xab, regs + 0x524);
+				udelay(50);
+				tmp = readl(regs + 0x524);
+				udelay(50);
+				writel(0x2b, regs + 0x524);
+				udelay(50);
+				tmp = readl(regs + 0x524);
+				udelay(50);
+				writel(0x10ab, regs + 0x524);
+				udelay(50);
+				tmp = readl(regs + 0x524);
+				SPINWAIT((((tmp = readl(regs + 0x528)) & 0xc000) !=
+					0xc000), 100000);
+				if ((tmp & 0xc000) != 0xc000) {
+					printk("WARNING! USB20H mdio_rddata 0x%08x\n", tmp);
+				}
+				writel(0x80000000, regs + 0x528);
+				tmp = readl(regs + 0x314);
+				udelay(265);
+				writel(0x7ff, regs + 0x200);
+				udelay(10);
+
+				/* Take USB and HSIC out of non-driving modes */
+				writel(0, regs + 0x510);
+			} else {
+				writel(0x7ff, regs + 0x200);
+				udelay(1);
+			}
 		}
 
 		/* PRxxxx: War for 5354 failures. */
diff -urBp a/arch/mips/brcm-boards/bcm947xx/setup.c b/arch/mips/brcm-boards/bcm947xx/setup.c
--- a/arch/mips/brcm-boards/bcm947xx/setup.c	2010-01-07 06:35:14.000000000 +0300
+++ b/arch/mips/brcm-boards/bcm947xx/setup.c	2011-05-12 11:16:15.000000000 +0400
@@ -81,6 +81,29 @@ EXPORT_SYMBOL(bcm947xx_sih_lock);
 
 /* Kernel command line */
 extern char arcs_cmdline[CL_SIZE];
+static int lanports_enable = 0;
+static int wombo_reset = GPIO_PIN_NOTDEFINED;
+
+static void
+bcm947xx_reboot_handler(void)
+{
+	if (lanports_enable) {
+		uint lp = 1 << lanports_enable;
+
+		si_gpioout(sih, lp, 0, GPIO_DRV_PRIORITY);
+		si_gpioouten(sih, lp, lp, GPIO_DRV_PRIORITY);
+		bcm_mdelay(1);
+	}
+
+	/* gpio 0 is also valid wombo_reset */
+	if (wombo_reset != GPIO_PIN_NOTDEFINED) {
+		int reset = 1 << wombo_reset;
+
+		si_gpioout(sih, reset, 0, GPIO_DRV_PRIORITY);
+		si_gpioouten(sih, reset, reset, GPIO_DRV_PRIORITY);
+		bcm_mdelay(10);
+	}
+}
 
 void
 bcm947xx_machine_restart(char *command)
@@ -93,6 +118,7 @@ bcm947xx_machine_restart(char *command)
 
 	/* Set the watchdog timer to reset immediately */
 	local_irq_disable();
+	bcm947xx_reboot_handler();
 	hnd_cpu_reset(sih);
 }
 
@@ -104,6 +130,7 @@ bcm947xx_machine_halt(void)
 	/* Disable interrupts and watchdog and spin forever */
 	local_irq_disable();
 	si_watchdog(sih, 0);
+	bcm947xx_reboot_handler();
 	while (1);
 }
 
@@ -178,6 +205,25 @@ brcm_setup(void)
 		strncpy(arcs_cmdline, value, sizeof(arcs_cmdline));
 
 
+	if ((lanports_enable = getgpiopin(NULL, "lanports_enable", GPIO_PIN_NOTDEFINED)) ==
+		GPIO_PIN_NOTDEFINED)
+		lanports_enable = 0;
+
+	/* wombo reset */
+	if ((wombo_reset = getgpiopin(NULL, "wombo_reset", GPIO_PIN_NOTDEFINED)) !=
+	    GPIO_PIN_NOTDEFINED) {
+		int reset = 1 << wombo_reset;
+
+		printk("wombo_reset set to gpio %d\n", wombo_reset);
+
+		si_gpioout(sih, reset, 0, GPIO_DRV_PRIORITY);
+		si_gpioouten(sih, reset, reset, GPIO_DRV_PRIORITY);
+		bcm_mdelay(10);
+
+		si_gpioout(sih, reset, reset, GPIO_DRV_PRIORITY);
+		bcm_mdelay(20);
+	}
+
 	/* Generic setup */
 	_machine_restart = bcm947xx_machine_restart;
 	_machine_halt = bcm947xx_machine_halt;
diff -uB a/drivers/net/hnd/Kconfig b/drivers/net/hnd/Kconfig
--- a/drivers/net/hnd/Kconfig
+++ b/drivers/net/hnd/Kconfig
@@ -39,6 +39,9 @@
 	tristate "BCM43xx 802.11 Wireless support"
 	depends on HND && !WL_EMULATOR
 #	select WIRELESS_EXT
+config WAPI
+	bool "Wireless Authentication Privacy Infrastructure (WAPI) support"
+	depends on HND && !WL_EMULATOR && WL
 choice
 	prompt "Wireless feature variant"
 	depends on HND && !WL_EMULATOR && WL
diff -urBp a/sound/soc/bcm947xx/bcm947xx-i2s.c b/sound/soc/bcm947xx/bcm947xx-i2s.c
--- a/sound/soc/bcm947xx/bcm947xx-i2s.c	2009-11-26 02:43:16.000000000 +0300
+++ b/sound/soc/bcm947xx/bcm947xx-i2s.c	2010-11-22 12:01:14.000000000 +0300
@@ -35,6 +35,7 @@
 #include <hnddma.h>
 #include <sbchipc.h>
 #include <i2s_core.h>
+#include <hndpmu.h>
 
 #include "bcm947xx-i2s.h"
 
@@ -253,6 +255,10 @@ static int bcm947xx_i2s_hw_params(struct
 	devctrl &= ~I2S_DC_WL_TX_MASK;
 	stxctrl &= ~I2S_STXC_WL_MASK;
 	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_U8:
+		devctrl |= 0x4000;
+		stxctrl |= 0x1000;
+		break;
 	case SNDRV_PCM_FORMAT_S16_LE:
 		devctrl |= 0x0;
 		stxctrl |= 0x0;
@@ -282,8 +288,14 @@ static int bcm947xx_i2s_hw_params(struct
 
 	/* Write I2S devcontrol reg */
 	W_REG(snd_bcm.osh, &snd_bcm->regs->devcontrol, devctrl);
+	devctrl |= I2S_DC_I2SCFG;  /* Set up core's SRAM for Half duplex Tx */
+	W_REG(snd_bcm.osh, &snd_bcm->regs->devcontrol, devctrl);
 	W_REG(snd_bcm.osh, &snd_bcm->regs->stxctrl, stxctrl);
+	DBG("%s: set devctrl 0x%x && stxctrl 0x%x\n", __FUNCTION__, devctrl, stxctrl);
 
+	DBG("%s: read devctrl 0x%x stxctrl 0x%x\n", __FUNCTION__,
+	    R_REG(snd_bcm.osh, &snd_bcm->regs->devcontrol),
+	    R_REG(snd_bcm.osh, &snd_bcm->regs->stxctrl));
 	return 0;
 }
 
@@ -351,11 +363,10 @@ bcm947xx_i2s_pci_attach(uint16 vendor, u
 	bcm947xx_i2s_info_t *snd = NULL;
 	int ret;
 
-	uint addrwidth;
 	int dma_attach_err = 0;
 
 
-	DBG("%s: vendor 0x%x device 0x%x regs 0x%x bustype 0x%x btparam %p irq 0x%x\n",
+	DBG("%s: vendor 0x%x device 0x%x regs 0x%lx bustype 0x%x btparam %p irq 0x%x\n",
 	    __FUNCTION__, vendor, device, regs, bustype, btparam, irq);
 
 
@@ -387,8 +398,7 @@ bcm947xx_i2s_pci_attach(uint16 vendor, u
 	                        NULL, NULL);
 
 	snd->regs = (i2sregs_t *)si_setcore(snd->sih, I2S_CORE_ID, 0);
-
-	addrwidth = dma_addrwidth(snd->sih, DMAREG(snd, DMA_TX, 0));
+	si_core_reset(snd->sih, 0, 0);
 
 	snd->di[0] = dma_attach(snd->osh, "i2s_dma", snd->sih,
 	                            DMAREG(snd, DMA_TX, 0),
@@ -400,12 +410,19 @@ bcm947xx_i2s_pci_attach(uint16 vendor, u
 	/* Tell DMA that we're not using framed/packet data */
 	dma_ctrlflags(snd->di[0], DMA_CTRL_UNFRAMED /* mask */, DMA_CTRL_UNFRAMED /* value */);
 
-	/* for 471X chips, Turn on I2S pins. They're MUX'd with PFLASH pins, and PFLASH is ON
-	 * by default
-	 */
 	if (CHIPID(snd->sih->chip) == BCM4716_CHIP_ID) {
+		/* for 471X chips, Turn on I2S pins. They're MUX'd with PFLASH pins, and PFLASH
+		 * is ON by default
+		 */
 		ret = si_corereg(snd->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol),
-	                 CCTRL471X_I2S_PINS_ENABLE, CCTRL471X_I2S_PINS_ENABLE);
+	                 CCTRL_471X_I2S_PINS_ENABLE, CCTRL_471X_I2S_PINS_ENABLE);
+	} else if (CHIPID(snd->sih->chip) == BCM5357_CHIP_ID) {
+		/* Write to the 2nd chipcontrol reg. to turn on I2S pins */
+		ret = si_pmu_chipcontrol(snd->sih, PMU1_PLL0_CHIPCTL1, CCTRL_5357_I2S_PINS_ENABLE,
+		                         CCTRL_5357_I2S_PINS_ENABLE);
+		/* Write to the 2nd chipcontrol reg. to turn on I2C-via-gpio pins */
+		ret = si_pmu_chipcontrol(snd->sih, PMU1_PLL0_CHIPCTL1,
+		                         CCTRL_5357_I2CSPI_PINS_ENABLE, 0);
 	}
 
 	return snd;
@@ -453,7 +470,6 @@ bcm947xx_i2s_pci_probe(struct pci_dev *p
 		return -ENODEV;
 
 	pci_set_drvdata(pdev, snd_bcm);
-	DBG("%s: snd_bcm @ %p snd_bcm.regs @ %p\n", __FUNCTION__, snd_bcm, snd_bcm.regs);
 
 	return err;
 }
